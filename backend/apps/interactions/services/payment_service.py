import base64
from typing import Any, Protocol, runtime_checkable

import requests
from django.conf import settings

from apps.interactions.exceptions import PaymentFailedException


@runtime_checkable
class PaymentGatewayAdapter(Protocol):
    """Protocol for payment gateway adapters."""

    def approve(self, payment_key: str, order_id: str, amount: int) -> dict[str, Any]:
        """
        Approve a payment.

        Args:
            payment_key: The payment key provided by the gateway.
            order_id: The order ID generated by the application.
            amount: The amount to be paid.

        Returns:
            dict: The response from the payment gateway.
        """
        ...

    def cancel(self, payment_key: str, cancel_reason: str) -> dict[str, Any]:
        """
        Cancel a payment.

        Args:
            payment_key: The payment key to cancel.
            cancel_reason: The reason for cancellation.

        Returns:
            dict: The response from the payment gateway.
        """
        ...


class TossPaymentAdapter:
    """Adapter for Toss Payments API."""

    BASE_URL = "https://api.tosspayments.com/v1/payments"

    def __init__(self) -> None:
        self.secret_key = settings.TOSS_PAYMENTS_SECRET_KEY

    def _get_headers(self) -> dict[str, str]:
        """Generate headers for Toss Payments API."""
        if not self.secret_key:
            return {}

        # Toss Payments requires Basic Auth with Secret Key and empty password
        # Format: "Basic base64(SECRET_KEY:)"
        secret_key_bytes = f"{self.secret_key}:".encode()
        encoded_key = base64.b64encode(secret_key_bytes).decode("utf-8")

        return {
            "Authorization": f"Basic {encoded_key}",
            "Content-Type": "application/json",
        }

    def _is_mock_mode(self) -> bool:
        """Check if mock mode should be used."""
        # Prefer an explicit setting to control mock mode. If the setting is
        # not defined, fall back to treating a missing secret key as mock mode.
        use_mock = getattr(settings, "TOSS_PAYMENTS_USE_MOCK", None)
        if use_mock is not None:
            return bool(use_mock)

        return self.secret_key is None

    def approve(self, payment_key: str, order_id: str, amount: int) -> dict[str, Any]:
        """
        Approve a payment using Toss Payments API.

        If using a test key or no key, returns a mock success response.
        """
        if self._is_mock_mode():
            return {
                "paymentKey": payment_key,
                "orderId": order_id,
                "amount": amount,
                "status": "DONE",
                "method": "카드",
                "totalAmount": amount,
                "approvedAt": "2024-01-01T00:00:00+09:00",
                "mock": True,
            }

        url = f"{self.BASE_URL}/confirm"
        data = {
            "paymentKey": payment_key,
            "orderId": order_id,
            "amount": amount,
        }

        try:
            response = requests.post(url, json=data, headers=self._get_headers(), timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            error_msg = "Payment approval failed"
            details = None

            if hasattr(e, "response") and e.response is not None:
                try:
                    details = e.response.json()
                    if "message" in details:
                        error_msg = details["message"]
                except ValueError:
                    # If the error response body is not valid JSON, ignore parsing failures
                    # and fall back to the default error message and details.
                    pass

            raise PaymentFailedException(message=error_msg, details=details) from e

    def cancel(self, payment_key: str, cancel_reason: str) -> dict[str, Any]:
        """
        Cancel a payment using Toss Payments API.
        """
        if self._is_mock_mode():
            return {
                "paymentKey": payment_key,
                "status": "CANCELED",
                "cancelReason": cancel_reason,
                "mock": True,
            }

        url = f"{self.BASE_URL}/{payment_key}/cancel"
        data = {"cancelReason": cancel_reason}

        try:
            response = requests.post(url, json=data, headers=self._get_headers(), timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            error_msg = "Payment cancellation failed"
            details = None

            if hasattr(e, "response") and e.response is not None:
                try:
                    details = e.response.json()
                    if "message" in details:
                        error_msg = details["message"]
                except ValueError:
                    # If the error response body is not valid JSON, ignore parsing failures
                    # and fall back to the default error message and details.
                    pass

            raise PaymentFailedException(message=error_msg, details=details) from e


class PaymentService:
    """Service for handling payment operations."""

    def __init__(self, adapter: PaymentGatewayAdapter | None = None) -> None:
        self.adapter = adapter or TossPaymentAdapter()

    def confirm_payment(self, payment_key: str, order_id: str, amount: int) -> dict[str, Any]:
        """
        Confirm a payment through the configured gateway.

        Args:
            payment_key: The payment key provided by the gateway.
            order_id: The order ID generated by the application.
            amount: The amount to be paid.

        Returns:
            dict: The successful payment details.

        Raises:
            PaymentFailedException: If the payment confirmation fails.
        """
        return self.adapter.approve(payment_key, order_id, amount)

    def cancel_payment(self, payment_key: str, cancel_reason: str) -> dict[str, Any]:
        """
        Cancel a payment through the configured gateway.

        Args:
            payment_key: The payment key to cancel.
            cancel_reason: The reason for cancellation.

        Returns:
            dict: The cancellation details.

        Raises:
            PaymentFailedException: If the payment cancellation fails.
        """
        return self.adapter.cancel(payment_key, cancel_reason)
